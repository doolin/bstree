\documentclass{article}

\usepackage{cite}

\title{Some notes on binary search trees}
\date{\today}
\author{David M. Doolin}


\begin{document}

\maketitle

\abstract{A few notes on binary search trees and their implementations
in various programming languages.}



\section{Introduction}


The following topics will be discussed:

\begin{itemize}

\item Differences in implementations between programming languages.
\item How best to containerize, including pure tree node, tree wrapper with
node class, abstracting keys.
\item Theory and performance.

\end{itemize}


\section{Literature review}

Skiena~\cite[pp. 77, 370, 375, 589]{skiena} has a few notes.


Rosen~\cite[pp. 757-760]{rosen} discusses three uses for binary search trees:

\begin{enumerate}
\item storing items from a list such that they can be easily found;
\item finding an object in a collection of similar objects;
\item efficiently encoding characters in a bit string.
\end{enumerate}

\subsection{Collisions or duplicate values}

None the preceding references explicitly discuss collisions.

* The duplicate key can be added to the tree, either silently or with a warning.
* The duplicate key is not added to the tree, either silently or with a warning.

* In Ruby, does replacing a node in a tree leak memory, or will the deleted node
get garbage collected? How about Python?

* How to delete in c/c++ such that memory isn't leaked? This should be easier,
call delete after the node is orphaned.

\section{Persistence}

Here are some ways to store the structure in text format:

\begin{enumerate}
\item Write to nested json. This requires writing out from the top
down. Should be able to do this by converting to hash, then
writing to json. Reading in is the reverse. How to convert a
hash to a binary tree? Maybe this is where to use combinator.

\item CSV: does this require top down, or can it be done by traversing?
Does it require a parent pointer?

\item Yaml: how are references handled?
\end{enumerate}


\section{Breadth-first traversal}

Breadth-first traveral can be used for searching, for determining whether a key exists,
or for writing out the tree in flat format with rows and pointers.

For persistence, we have the following:

\begin{itemize}
\item At each node we can store pointers to each child.
\item We can store the start and the stop of each row separately.
\item We can store an array of arrays, where each of the arrays is
      one level of the tree.
\end{itemize}

[
 [root],
 [ root.left, root.right],
 [...]
]

Can all the pointers be stored in one pass, then process in a second pass,
or can the nodes be processes as the breadth-first traverse proceeds?



\section{Containerizing}

\subsection{C++ templating}

\subsection{C struct inclusion}

\subsection{Ruby module inclusion}

Not sure if this will work, but it would be cool to have a Ruby module which
adds binary search tree capability to any object. The methods would have to be
class methods.

\section{References}

\bibliography{references}{}
\bibliographystyle{plain}

\section{Summary}

\appendix



\end{document}
